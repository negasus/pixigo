package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"

	"golang.org/x/tools/imports"
)

type args struct {
	srcDir      string
	srcType     string
	destType    string
	destPackage string
	outputFile  string
}

var doc = "// Code generated by cmd/gen %s. DO NOT EDIT.\n"

func main() {
	opts := args{}
	errParseFlags := parseFlags(&opts)
	if errParseFlags != nil {
		fmt.Printf("Error parsing flags: %v\n", errParseFlags)
		os.Exit(1)
	}

	if opts.outputFile == "" {
		opts.outputFile = strings.ToLower(fmt.Sprintf("%s_%s.go", opts.destType, opts.srcType))
	}

	entries, errParseDir := parser.ParseDir(token.NewFileSet(), opts.srcDir, nil, 0)
	if errParseDir != nil {
		fmt.Printf("Error parsing directory: %v\n", errParseDir)
		os.Exit(1)
	}

	result := &ast.File{
		Name: ast.NewIdent(opts.destPackage),
	}

	for _, entry := range entries {
		for _, file := range entry.Files {
			for _, decl := range file.Decls {
				switch d := decl.(type) {
				case *ast.GenDecl:
					parseGenDecl(d, result)
				case *ast.FuncDecl:
					parseFuncDecl(d, opts, result)
				default:
					continue

				}
			}
		}
	}

	buf := bytes.NewBuffer(nil)

	errFormat := format.Node(buf, token.NewFileSet(), result)
	if errFormat != nil {
		fmt.Printf("Error formatting output: %v\n", errFormat)
		os.Exit(1)
	}

	bufImports, errImports := imports.Process(opts.outputFile, buf.Bytes(), nil)
	if errImports != nil {
		fmt.Printf("Error processing imports: %v\n", errImports)
		os.Exit(1)
	}

	s := fmt.Sprintf(doc, strings.Join(os.Args[1:], " "))

	bufImports = append([]byte(s), bufImports...)

	errWrite := os.WriteFile(opts.outputFile, bufImports, 0644)
	if errWrite != nil {
		fmt.Printf("Error writing output: %v\n", errWrite)
		os.Exit(1)
	}

	fmt.Printf("generated %s\n", opts.outputFile)
}

func parseFuncDecl(d *ast.FuncDecl, opts args, result *ast.File) {
	if d.Name == nil {
		return
	}

	if d.Name.Name == "JSV" || d.Name.Name == "SetJSV" {
		return
	}

	if d.Recv == nil {
		return
	}
	if len(d.Recv.List) != 1 {
		return
	}
	f := d.Recv.List[0]

	se, okSE := f.Type.(*ast.StarExpr)
	if !okSE {
		return
	}

	ident, okIdent := se.X.(*ast.Ident)
	if !okIdent {
		return
	}
	if ident.Name != opts.srcType {
		return
	}

	dd := *d

	dd.Recv.List[0].Type = &ast.StarExpr{
		X: &ast.Ident{
			Name: opts.destType,
		},
	}

	result.Decls = append(result.Decls, &dd)
}

func parseGenDecl(d *ast.GenDecl, result *ast.File) {
	if d.Tok == token.IMPORT {
		result.Decls = append(result.Decls, d)
	}
}
